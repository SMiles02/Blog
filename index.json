[{"content":"As the new year begins, so does my annual tradition of writing my review of 2025 and setting goals for 2026 1. Alongside the more serious ones, I wanted to pick up a few lighter skills too.\nRecently, I\u0026rsquo;ve been reading about the Doomsday rule, an algorithm that allows you to determine the day of the week for any given date. With a bit of memorisation ‚Äî2 the anchor day for each century, and one anchor date per month ‚Äî you can efficiently calculate the day for any date!\nTo help myself learn this 3 more effectively, I built Day Guesser, a small web app to quiz myself. It\u0026rsquo;s not too complicated; built with simple HTML, CSS and JavaScript, with support for Markdown and LaTeX. Occasionally, web development ends up not making me contemplate the quickest way to end myself, and fortunately, this was one of those times!\nCurrently, I\u0026rsquo;m at about 15 seconds per mental computation and I\u0026rsquo;d like to improve that quite a bit. John Conway ‚Äî yes, the creator of the game of Life John Conway ‚Äî who devised the algorithm, could allegedly give the correct answer in under two seconds per query!\nWriting more on this blog is one of them\u0026hellip;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThis is perhaps the most tragic time in recorded history for anyone to start using em-dashes in writing: I promise I am not AI-writing my blogs üôè\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nAlso to aurafarm in nerd social circles\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://blog.suneetmahajan.com/posts/day-guesser/","summary":"A webapp that helps you learn to derive the day of the week for any date","title":"Day Guesser"},{"content":"This report was submitted as my final year dissertation for CS4701.\n","permalink":"https://blog.suneetmahajan.com/posts/optimal-control/","summary":"My undergraduate thesis","title":"Final Year Project: Optimal Control \u0026 Backpropagation"},{"content":"A few days ago, I decided to catch up on my long-neglected manga reading-list. One particular manga1 made a joke in passing about prime-number cicadas, leaving me stumped. Two days, and a lot of scrolling, later, here\u0026rsquo;s what I\u0026rsquo;ve learned.\nCicadas are loud, plant-sap-feeding insects famous for their buzzing songs, unfortunately not found in Ireland, and certainly not one I\u0026rsquo;d have expected to be mentioned in a sentence about number theory. Enter Magicicada2, a genus of cicadas famous for their bizarre life cycles.\nUnlike other types of cicadas, Magicicadas spend the majority of their exceptionally long lives underground, emerging only after 13 or 17 years to sing, mate, and die3. The beauty lies in these specific (prime, as you may have guessed from the title) numbers: why 13 or 17 years?\nPrime numbers have an innate property: they don\u0026rsquo;t overlap easily with other numbers. For Magicicadas, this means fewer run-ins with peak (i.e. mature and most adept at feasting on these cicadas) predator populations, and thus more cicadas surviving to repeat the cycle. Many of the typical predators of cicadas, such as certain beetles or wasps, only emerge as adults (and pose a threat) during the final year of their life cycle.\nFor example, a 4-year predator and a 17-year cicada would only meet once every $\\text{LCM}(4, 17) = 68$ years. Had the cicadas emerged every 16 years instead, the meeting would occur every $\\text{LCM}(4, 16) = 16$ years - a relatively small change in emergence time leading to rendezvous four times more frequent‚Äîpotentially devastating for the population.\nThis prime-number strategy, combined with the predator satiation strategy employed, where the cicadas emerge in overwhelming numbers to \u0026lsquo;flood\u0026rsquo; predators, ensures the survival of enough individuals to reproduce even if many are eaten.\nI never expected a casual manga binge to lead me to the real-world utilisations of number theory in nature, but here I was, marvelling at how a stupid one-liner on \u0026ldquo;prime-number watermelons\u0026rdquo; contained so much fascinating mathematical lore.\n\u0026ldquo;Shiretto Sugee Koto Iteru Gal. - Shiritsu Paranormal Koukou no Nichijou\u0026rdquo;, a pretty underrated surreal comedy - worth a read!\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nAmazingly named, by the way, though I\u0026rsquo;m not sure how I\u0026rsquo;d go about pronouncing it.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWhy is a cicada living a better life than me\u0026hellip;?\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://blog.suneetmahajan.com/posts/prime-cicadas/","summary":"How reading manga led to me spending two days reading about insect breeding cycles.","title":"Are You Worse at Maths than a Cicada?"},{"content":"Here is a quick editorial for the problems from WEOI 2024, in order from easiest expected problem to hardest, along with my solutions.\nYou can attempt these problems on the mirror contest page on Codeforces.\nMazes (mazes) Full Solution From subtask $4$, we can come up with a pattern to solve for all powers of two. The construction I used created the following pattern for $K = 8$ and is easily generalisable for all powers of two:\n...##### .#.##### ......## ###.#.## ###...## #####... #####.#. #####... We can add an \u0026ldquo;early-exit\u0026rdquo; for powers of $2$ that are used in the binary representation of $K$, and bring them directly to the end of the maze.\nFor example, for $K = 5 = 2^0 + 2^2$, we can add an early exit at the $K = 2^0$ and $K = 2^2$ squares.\n...##### .#.##### ......## .##.#.## .##...## .####.## .####.## ........ This will allow us to create a construction for any valid $K$.\nFull Solution Code #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; solve(long long K) { if (K == 1) { return {{\u0026#39;.\u0026#39;}}; } vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; ans(200, vector\u0026lt;char\u0026gt;(200, \u0026#39;#\u0026#39;)); ans[0][0] = \u0026#39;.\u0026#39;; ans[199] = vector\u0026lt;char\u0026gt;(200, \u0026#39;.\u0026#39;); int x = 0; long long done = 0; for (int p = 0; done != K; ++p) { for (int i = 0; i \u0026lt; 3; ++i) { for (int j = 0; j \u0026lt; 3; ++j) { ans[x + i][x + j] = \u0026#39;.\u0026#39;; } } ans[x + 1][x + 1] = \u0026#39;#\u0026#39;; if ((1LL \u0026lt;\u0026lt; p) \u0026amp; K) { for (int i = x; i \u0026lt; 200; ++i) { ans[i][x] = \u0026#39;.\u0026#39;; } done ^= 1LL \u0026lt;\u0026lt; p; } x += 2; } return ans; } Double Agents (trees) Full Solution to-do\nFull Solution Code #include \u0026lt;vector\u0026gt; using namespace std; const int MOD = 1e9 + 7; int add(int x, int y) { x += y; if (x \u0026gt;= MOD) { x -= MOD; } return x; } int sub(int x, int y) { x -= y; if (x \u0026lt; 0) { x += MOD; } return x; } int mul(int a, int b) { return (1LL * a * b) % MOD; } void dfs(int cur, int par, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; e, vector\u0026lt;int\u0026gt;\u0026amp; ways, vector\u0026lt;int\u0026gt;\u0026amp; ways_constrained) { ways[cur] = 1; int cnt1 = 0, cnt2 = 1; for (int child : e[cur]) { if (child == par) { continue; } dfs(child, cur, e, ways, ways_constrained); // fill root and one child subtree ways[cur] = add(ways[cur], ways_constrained[child]); // do not fill root, fill at least two child subtrees cnt2 = mul(cnt2, add(ways_constrained[child], 1)); ways[cur] = sub(ways[cur], ways_constrained[child]); // do not fill root, fill only one child subtree cnt1 = add(cnt1, ways[child]); } ways[cur] = add(sub(ways[cur], 1), add(cnt1, cnt2)); ways_constrained[cur] = 1; int cnt = 1; for (int child : e[cur]) { if (child == par) { continue; } cnt = mul(cnt, add(ways_constrained[child], 1)); } ways_constrained[cur] = add(ways_constrained[cur], sub(cnt, 1)); } int count_sets(int N, vector\u0026lt;int\u0026gt; u, vector\u0026lt;int\u0026gt; v) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; e(N); vector\u0026lt;int\u0026gt; ways(N), ways_constrained(N); for (int i = 0; i + 1 \u0026lt; N; ++i) { e[u[i]].push_back(v[i]); e[v[i]].push_back(u[i]); } dfs(0, -1, e, ways, ways_constrained); return ways[0]; } Parcel Post (multihop) Full Solution Root the tree arbitrarily. Note that we can calculate the cost of moving from a node $U$ to its immediate ancestor (i.e. parent) $V$ very easily, it\u0026rsquo;s just $\\min(A_i, B_i + C)$, where $i$ is the indice of the edge connecting $U$ and $V$.\nIf we keep track of some additional information, such as whether a path from a node to its ancestor starts and/or ends using a high power firing, we can keep track of $4$ states for each node from itself to its parent. Now, since we have the cost to get from a node to its $2^0 = 1$-st ancestor, we can use binary lifting to calculate the cost, for each station, to its $i$-th ancestor for all $1 \\le i \\le 16$, with a little bit of casework for matching the states (you can see it in my code below!).\nWe can do the same binary lifting-dp to keep track of costs for downwards paths in the tree. Now, the cost of a path from $U$ to $V$ can be broken down into two paths: one upwards path from $U$ to $L$, the lowest common ancestor of $U$ and $V$, and one downwards path from $L$ to $V$. Combining these two paths will tell us the lowest common cost for sending a parcel on this path.\nTime complexity: $O(n \\log n)$\nFull Solution Code #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; using namespace std; struct min_cost { array\u0026lt;array\u0026lt;long long, 2\u0026gt;, 2\u0026gt; mc; // prefix/suffix closed/open void init() { for (int i = 0; i \u0026lt; 2; ++i) { for (int j = 0; j \u0026lt; 2; ++j) { mc[i][j] = 1e18; } } } }; const int N = 1e5, L = 17; int p[N], h[N], a[N], b[N], c, lift[L][N]; vector\u0026lt;int\u0026gt; e[N]; min_cost dp_up[L][N], dp_down[L][N]; min_cost merge(min_cost first, min_cost second) { min_cost ans; ans.init(); for (int i = 0; i \u0026lt; 2; ++i) { for (int j = 0; j \u0026lt; 2; ++j) { for (int k = 0; k \u0026lt; 2; ++k) { ans.mc[i][k] = min(ans.mc[i][k], first.mc[i][j] + second.mc[j][k]); } } } return ans; } void dfs(int cur) { for (int i = 1; (1 \u0026lt;\u0026lt; i) \u0026lt;= h[cur]; ++i) { lift[i][cur] = lift[i - 1][lift[i - 1][cur]]; dp_up[i][cur] = merge(dp_up[i - 1][cur], dp_up[i - 1][lift[i - 1][cur]]); dp_down[i][cur] = merge(dp_down[i - 1][lift[i - 1][cur]], dp_down[i - 1][cur]); } for (int i : e[cur]) { if (i == p[cur]) { continue; } p[i] = cur; h[i] = h[cur] + 1; lift[0][i] = cur; dp_up[0][i].mc[0][0] = min(a[i], b[i] + c); dp_up[0][i].mc[0][1] = min(a[i] + b[cur], b[i] + c); dp_up[0][i].mc[1][0] = min(c, a[i]); dp_up[0][i].mc[1][1] = min(c, a[i] + b[cur]); dp_down[0][i].mc[0][0] = min(a[cur], b[cur] + c); dp_down[0][i].mc[0][1] = min(a[cur] + b[i], b[cur] + c); dp_down[0][i].mc[1][0] = min(c, a[cur]); dp_down[0][i].mc[1][1] = min(c, a[cur] + b[i]); dfs(i); } } void init(int n, int C, vector\u0026lt;int\u0026gt; A, vector\u0026lt;int\u0026gt; B, vector\u0026lt;int\u0026gt; u, vector\u0026lt;int\u0026gt; v) { for (int i = 0; i \u0026lt; n; ++i) { a[i] = A[i]; b[i] = B[i]; } c = C; for (int i = 0; i \u0026lt; n - 1; ++i) { e[u[i]].push_back(v[i]); e[v[i]].push_back(u[i]); } dfs(0); } int lca(int x, int y) { if (h[x] \u0026lt; h[y]) { swap(x, y); } for (int i = 0; i \u0026lt; L; ++i) { if ((h[x] - h[y]) \u0026amp; (1 \u0026lt;\u0026lt; i)) { x = lift[i][x]; } } if (x == y) { return x; } for (int i = L - 1; i \u0026gt;= 0; --i) { if (lift[i][x] != lift[i][y]) { x = lift[i][x]; y = lift[i][y]; } } return lift[0][x]; } long long query(int x, int y) { int z = lca(x, y); min_cost cur_ans; cur_ans.init(); cur_ans.mc[0][0] = 0; vector\u0026lt;array\u0026lt;int, 2\u0026gt;\u0026gt; v; for (int i = 0; i \u0026lt; L; ++i) { if ((h[x] - h[z]) \u0026amp; (1 \u0026lt;\u0026lt; i)) { cur_ans = merge(cur_ans, dp_up[i][x]); x = lift[i][x]; } if ((h[y] - h[z]) \u0026amp; (1 \u0026lt;\u0026lt; i)) { v.push_back({y, i}); y = lift[i][y]; } } while (!v.empty()) { cur_ans = merge(cur_ans, dp_down[v.back()[1]][v.back()[0]]); v.pop_back(); } return cur_ans.mc[0][0]; } Make All Equal (equal) Full Solution From Subtask $3$, we can come up with a method for making $N = 2$ piles of stones equal: starting from $i = 19$ and working down to $0$, we can add $2^i$ stones to the smaller pile. After the $i$-th operation, we can be sure that the difference between $H_0$ and $H_1$ is no more than $2^i$, that is, $| H_0 - H_1 | \\le 2^i$. Our last operation ensures that the difference between the two is at most $2^0 = 1$, after which we can use a singular one of our $\\textit{compare}$ operations to check whether $H_0$ and $H_1$ are equal. If they are not, we add $1$ stone to $H_0$, and after doing so, $H_0 = H_1$, as desired.\nAn intuitive idea follows: we can use a divide-and-conquer-esque method with segment merging, and solve our problem layer by layer, i.e. before solving for $[1, 2^{i + 1}]$, solve for $[1, 2^i]$ and $[2^i + 1, 2^{i + 1}]$, and make each subsegment equal first before making the new segment equal. This however, takes about $20 \\times 2047$ $\\textit{add}$ operations, which is not sufficient.\nWe notice that on each layer - each segment of length $2^i$ - all merges of subsegments are independent, and thus can occur at the same time. Now, for each layer, we perform about $20$ (plus some extra, I\u0026rsquo;ll leave it as an implementation detail :P) $\\textit{add}$ operations, which solves the problem.\nFull Solution Code #include \u0026#34;equal.h\u0026#34; #include \u0026lt;vector\u0026gt; using namespace std; void make_all_equal(int N, int, int) { for (int p = 2; p \u0026lt;= N; p *= 2) { vector\u0026lt;int\u0026gt; query_indices; for (int i = 0; i + p - 1 \u0026lt; N; i += p) { for (int j = i; j \u0026lt; i + p / 2; ++j) { query_indices.push_back(j); } } for (int i = 18 + __lg(p); i \u0026gt;= 0; --i) { add(query_indices, 1 \u0026lt;\u0026lt; i); } query_indices.clear(); for (int i = 0; i + p - 1 \u0026lt; N; i += p) { if (!compare(i, i + p - 1)) { for (int j = i; j \u0026lt; i + p / 2; ++j) { query_indices.push_back(j); } } } if (!query_indices.empty()) { add(query_indices, 1); } } } ","permalink":"https://blog.suneetmahajan.com/posts/weoi-2024-editorial/","summary":"A quick explanation of the solutions from WEOI 2024, held in London, UK","title":"Western European Olympiad in Informatics 2024 Editorial"},{"content":"This post was originally written on Codeforces; relevant discussion can be found here.\nI\u0026rsquo;ve been meaning to write a blog about this interesting, but not (as far as I know) documented trick for a while. I\u0026rsquo;ve decided to call it the Amogus trick after the first problem where I encountered and used it.\nPrerequisites DSU Basic knowledge of 2-SAT (definitely not required, but it may make the blog easier to understand) Focus Problem: CF1594D - The Number of Imposters First, let\u0026rsquo;s solve an easier version of this problem, where we just need to find whether there exists a configuration of player roles (i.e. Crewmate or Imposter) such that all the statements made by players so far are true.\nLet\u0026rsquo;s look at the two different types of statements made by players separately.\nCase 1: Player $i$ claims Player $j$ is a crewmate. Now, if Player $i$ is a crewmate, Player $j$ will also be a crewmate. Similarly, if Player $i$ is an imposter, Player $j$ will also be an imposter. The reversed versions of these statements are also true. Using this, we can create a virtual \u0026ldquo;edge\u0026rdquo; between Players $i$ and $j$, as their roles in the game will always be the same. More formally, for those familiar with 2-SAT or otherwise, we create the equivalency $v_i = v_j$.\nCase 2: Player $i$ claims Player $j$ is an imposter. Now, if Player $i$ is a crewmate, Player $j$ will be an imposter. Similarly, if Player $i$ is an imposter, Player $j$ will be a crewmate. We can create a virtual \u0026ldquo;anti-edge\u0026rdquo; between Players $i$ and $j$, as their roles in the game will always be the different. More formally, we create the equivalency $v_i = !v_j$.\nAdding edges is easy, we can just use normal DSU. But how do we deal with anti-edges? This is where the Amogus Trick comes in!\nWe can deal with these anti-edges by creating a DSU with $2n$ nodes, where nodes $1$ to $n$ represent player $i$ being a crewmate, and nodes $n + 1$ to $2n$ represent player $i - n$ being an imposter. Now, let\u0026rsquo;s look at those cases again.\nCase 1 results in both players having the same role in the game. Therefore, when such a statement is said, we can unite nodes $i$ and $j$, and similarly, unite nodes $i + n$ and $j + n$.\nCase 2 results in both players having differing roles in the game. Therefore, when such a statement is said, we can unite nodes $i$ and $j + n$, and similarly, unite nodes $i + n$ and $j$.\nTestcases 2 \u0026amp; 3 of the sample input in the problem, respectively, visualised with the Amogus trick:\nSo, how can we solve our reduced problem with this? Note that a player can be exactly one of $\\{ \\text{Crewmate, Imposter} \\}$, so a configuration is invalid iff for some $1 \\le i \\le n$, nodes $i$ and $i + n$ are in the same component in our DSU. This is the only condition we need to check, as since the edges we add to our DSU are symmetric, there will always be a valid assignment of roles.\nIt\u0026rsquo;s not too difficult to extend this idea to solve our original problem.\nFull Solution Provided that there exists a solution for our configuration. We can give each node from $1$ to $n$ a weight of $0$, and each node from $n + 1$ to $2n$ a weight of $1$, as we only care about the number of imposters in our configuration. Now, for each pair of symmetric components, take the one that contains the maximum number of players being imposters.\nMy AC submission\nUsing this trick, we can solve a variety of other problems, such as dynamic bipartiteness checking, and it can often be paired with other modifications of DSU such as with support for rollbacks.\nOther Problems: Problems are ordered (roughly) in ascending order of difficulty.\nCF1702E - Split Into Two Sets\ntourist's AC Code 163478635\nCF1290C - Prefix Enlightenment\nMy AC Code 169912969\nCF1713E - Cross Swapping\nMy AC Code 169902868\nCF1444C - Team-Building\nMy AC Code 169902269\nA special thank you to kostia244, BucketPotato, fishy15 and AlperenT for providing feedback and/or sample problems!\n","permalink":"https://blog.suneetmahajan.com/posts/amogus-trick/","summary":"A self-named method to determine whether a binary system consisting of equations of the form xi = yi and xi =/= yi is solvable in O(Œ±(n) + m) time and O(n) memory, along with its applications in theoretical computer science problems","title":"Amogus Trick"}]